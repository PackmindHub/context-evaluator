# AI Agent Implicit Decision Log
#
# This file captures implicit technical decisions and uncertainties encountered
# by AI agents during coding work. It helps track what architectural and design
# choices were made without explicit user guidance or documented standards.
#
# Review this file periodically to:
# - Understand what technical choices were made and why
# - Identify what uncertainties the AI had during implementation
# - Validate or question specific implementation decisions
# - Identify patterns that should become formal standards
# - Create explicit guidelines in CLAUDE.md
# - Add standards to Packmind
# - Use signal-capture to formalize good patterns into standards
#
# File is managed by the implicit-decision-capture skill.
# Schema: See .claude/skills/implicit-decision-capture/SKILL.md

# Example entries showing the skill in action:

- timestamp: 2026-01-09T17:30:00Z
  file: .claude/skills/implicit-decision-capture/SKILL.md
  context: 'Creating the implicit-decision-capture skill'
  category: 'architecture'
  question: 'Should the decisions.yaml file be tracked in git or gitignored?'
  decision: 'Track in git so teams can collaborate on context improvement'
  reasoning: 'This is team-wide context that everyone should review and improve, similar to CLAUDE.md'
  alternatives:
    - 'Gitignore it and keep it local to each developer'
    - 'Make it optional via configuration'
  impact: 'global'
  confidence: 'high'
  source: 'pattern-matching'
  tags:
    - 'skill-design'
    - 'collaboration'
    - 'git'

- timestamp: 2026-01-09T17:45:00Z
  file: .claude/skills/implicit-decision-capture/SKILL.md
  context: 'Creating the implicit-decision-capture skill'
  category: 'architecture'
  decision: 'Merge uncertainty-capture and decision-capture into a single skill'
  reasoning: 'Both skills captured the same concept (implicit decisions) with only minor differences. A single skill reduces cognitive overhead and eliminates the "log to both files" edge case.'
  alternatives:
    - 'Keep separate skills for questions vs decisions'
    - 'Create three-way merge with a new skill'
  impact: 'global'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'skill-design'
    - 'simplification'
    - 'architecture'

- timestamp: 2026-01-15T10:30:00Z
  file: src/shared/claude/response-parser.ts
  context: 'Adding snippet extraction for issue locations'
  category: 'architecture'
  question: 'Should snippet extraction functions be in a new file or added to existing module?'
  decision: 'Add extractSnippet and populateSnippets functions to response-parser.ts'
  reasoning: 'Functions are closely related to issue parsing workflow. Keeps snippet population co-located with issue parsing logic.'
  alternatives:
    - 'Create new src/shared/utils/snippet-extractor.ts'
    - 'Add to runner.ts alongside evaluation logic'
  impact: 'module'
  confidence: 'medium'
  source: 'ai-agent'
  tags:
    - 'code-organization'
    - 'utility-functions'

- timestamp: 2026-01-15T10:35:00Z
  file: frontend/src/components/IssueCard.tsx
  context: 'Adding snippet display to issue cards'
  category: 'styling'
  question: 'Where should the snippet be displayed in the issue card layout?'
  decision: 'Display snippet immediately after location section, before affected files'
  reasoning: 'Snippet provides context for the location, so placing them together creates logical visual grouping.'
  alternatives:
    - 'Put in expandable details section at bottom'
    - 'Display inline with location in same row'
    - 'Show as a tooltip on location hover'
  impact: 'local'
  confidence: 'medium'
  source: 'ai-agent'
  tags:
    - 'ui-layout'
    - 'react'
    - 'issue-display'

- timestamp: 2026-01-15T14:20:00Z
  file: src/shared/claude/prompt-builder.ts
  context: 'Adding line numbers to content for accurate location tracking'
  category: 'patterns'
  question: 'What format should line numbers use when prefixing content lines?'
  decision: 'Use format "  N | content" with dynamic padding based on total line count'
  reasoning: 'Dynamic padding keeps alignment consistent regardless of file length. Pipe separator is unambiguous and commonly used in code display tools (e.g., git diff, cat -n style).'
  alternatives:
    - 'Fixed 4-character padding for all files'
    - 'Use colon separator (N: content)'
    - 'Use tab separator (N\tcontent)'
  impact: 'global'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'formatting'
    - 'prompt-engineering'
    - 'line-numbers'

- timestamp: 2026-01-15T14:22:00Z
  file: src/shared/claude/prompt-builder.ts
  context: 'Adding line numbers to content for accurate location tracking'
  category: 'architecture'
  question: 'Should addLineNumbers be a standalone utility or part of prompt-builder?'
  decision: 'Keep addLineNumbers as private function within prompt-builder.ts'
  reasoning: 'Function is specific to prompt construction and not needed elsewhere. Avoids creating another utility file for a single function.'
  alternatives:
    - 'Create src/shared/utils/line-numbers.ts'
    - 'Add to an existing utils module'
    - 'Export from prompt-builder for potential reuse'
  impact: 'local'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'code-organization'
    - 'prompt-building'

- timestamp: 2026-01-15T16:45:00Z
  file: prompts/evaluators/04-testing-validation.md
  context: 'Updating testing guidance evaluator to require real tests exist first'
  category: 'patterns'
  question: 'What criteria should define "real tests" vs auto-generated/placeholder tests?'
  decision: 'Define real tests as: (1) testing framework detected in project context, (2) test config files present, (3) established testing setup - explicitly exclude single sample files like default App.test.tsx'
  reasoning: 'Testing guidance is only actionable if the codebase has actual tests. Single auto-generated sample tests from scaffolding tools are not real test suites. The context-identifier already detects frameworks and config files, so leveraging that existing data is efficient.'
  alternatives:
    - 'Count test files and require minimum threshold (e.g., 3+ test files)'
    - 'Analyze test file content to detect placeholder patterns'
    - 'Only check for testing framework without config file requirement'
  impact: 'global'
  confidence: 'medium'
  source: 'ai-agent'
  tags:
    - 'evaluator-design'
    - 'testing'
    - 'prompt-engineering'

- timestamp: 2026-01-16T10:00:00Z
  file: frontend/src/App.tsx
  context: 'Increasing logo size in header and footer'
  category: 'styling'
  question: 'How much bigger should the logo be, and should header and footer logos be the same size?'
  decision: 'Increase header logo to 96px (w-24) and footer logo to 80px (w-20)'
  reasoning: 'Header logo needs to be prominent but not overwhelming (50% increase from 64px to 96px). Footer logo slightly smaller (80px) to maintain visual hierarchy - header is primary branding, footer is secondary.'
  alternatives:
    - 'Make both the same size (96px or 80px)'
    - 'Double the size to 128px'
    - 'Increase by smaller increment (72px)'
  impact: 'local'
  confidence: 'medium'
  source: 'ai-agent'
  tags:
    - 'ui-design'
    - 'branding'
    - 'visual-hierarchy'

- timestamp: 2026-01-19T18:45:00Z
  file: src/shared/evaluation/file-consistency-validator.ts
  context: 'Implementing AGENTS.md/CLAUDE.md coexistence detector'
  category: 'architecture'
  question: 'How should the unified diff be generated - with what context level?'
  decision: 'Use createTwoFilesPatch with 1-line context for unified diff output'
  reasoning: 'Plan specified "unified diff" but not the context lines. 1-line context provides enough surrounding code to understand changes without excessive verbosity. Common for tools like git diff.'
  alternatives:
    - 'No context lines (just changes)'
    - '3-line context (more context but longer output)'
    - 'Full file diff'
  impact: 'module'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'diff-generation'
    - 'validator-design'

- timestamp: 2026-01-19T18:46:00Z
  file: src/shared/evaluation/file-consistency-validator.ts
  context: 'Implementing AGENTS.md/CLAUDE.md coexistence detector'
  category: 'error-handling'
  question: 'How should errors during file reading or diff generation be handled?'
  decision: 'Catch errors and return empty result (0 issues) rather than throwing exceptions'
  reasoning: 'Validation is a pre-hook before main evaluation. Failing the entire evaluation due to file read errors is too strict. Continue gracefully, allowing evaluators to run even if consistency check fails.'
  alternatives:
    - 'Throw exceptions and fail fast'
    - 'Log error and continue (current choice is better)'
    - 'Return error issue object describing the failure'
  impact: 'module'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'error-handling'
    - 'robustness'

- timestamp: 2026-01-19T18:47:00Z
  file: src/shared/evaluation/file-consistency-validator.ts
  context: 'Implementing AGENTS.md/CLAUDE.md coexistence detector'
  category: 'patterns'
  question: 'Should file comparison be case-sensitive byte-for-byte, or trim whitespace?'
  decision: 'Use strict byte-for-byte comparison without trimming'
  reasoning: 'Plan specified "byte-for-byte comparison" explicitly. Not trimming catches whitespace differences (line ending variations, trailing spaces) which could indicate copy-paste errors or incomplete sync. Stricter validation is appropriate for critical severity issues.'
  alternatives:
    - 'Trim before comparing (catches content differences but misses whitespace issues)'
    - 'Case-insensitive comparison'
  impact: 'module'
  confidence: 'high'
  source: 'pattern-matching'
  tags:
    - 'comparison-strategy'
    - 'validation-rigor'

- timestamp: 2026-01-19T18:48:00Z
  file: src/shared/evaluation/engine.ts
  context: 'Integrating file consistency validator into evaluation engine'
  category: 'architecture'
  question: 'Should consistency issues be passed as method parameters or stored as instance properties?'
  decision: 'Pass consistencyIssues as method parameters to runUnifiedMode and runIndependentMode'
  reasoning: 'Keeps concerns isolated - validation result is input to evaluation modes, not shared state. Avoids coupling through instance properties. Method parameters make dependency clear and testable.'
  alternatives:
    - 'Store as class instance property and access in evaluation methods'
    - 'Global variable (antipattern)'
    - 'Nested object with all pre-validation results'
  impact: 'module'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'dependency-injection'
    - 'code-organization'
    - 'testability'

- timestamp: 2026-01-19T18:49:00Z
  file: src/shared/evaluation/file-consistency-validator.ts
  context: 'Creating Issue objects for conflicting files'
  category: 'patterns'
  question: 'How should location be structured for multi-file issues spanning both AGENTS.md and CLAUDE.md?'
  decision: 'Create Location[] array with both files, each having full file range (start: 1, end: lineCount)'
  reasoning: 'Issue affects entire files equally - not specific lines. Full range indicates file-level scope. Array format matches existing Issue type which accepts Location | Location[]. Parallel structure with affectedFiles array provides redundancy for UI rendering.'
  alternatives:
    - 'Single location pointing to directory'
    - 'Location for only first file'
    - 'Special multi-file location object'
  impact: 'module'
  confidence: 'high'
  source: 'pattern-matching'
  tags:
    - 'issue-structure'
    - 'multi-file-issues'

- timestamp: 2026-01-19T18:50:00Z
  file: src/shared/evaluation/engine.ts
  context: 'Integrating consistency validation into both evaluation modes'
  category: 'patterns'
  question: 'Should consistency issues be treated as per-file or cross-file issues?'
  decision: 'Treat consistency issues as cross-file issues and include in crossFileIssues array for both modes'
  reasoning: 'Consistency issues inherently span multiple files in same directory. Cross-file classification makes sense. Existing aggregation logic for cross-file issues handles all severity counting and display correctly without special handling.'
  alternatives:
    - 'Create separate consistency issues array'
    - 'Treat as per-file issues (incorrect semantic)'
    - 'Add new issue category to Issue type'
  impact: 'module'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'issue-classification'
    - 'cross-file-issues'

- timestamp: 2026-01-21T18:30:00Z
  file: frontend/src/components/IssueCard.tsx
  context: 'Implementing compact single-line issue card layout'
  category: 'styling'
  question: 'How much padding should compact cards use?'
  decision: 'Use p-3 (12px) padding instead of default p-4 (16px)'
  reasoning: 'Reduces card height by ~25% while maintaining sufficient spacing for readability. Aligns with compact design goal without making cards feel cramped.'
  alternatives:
    - 'Use p-2 (8px) - too compact, reduces readability'
    - 'Keep p-4 (16px) - not compact enough'
    - 'Use p-2.5 (10px) - non-standard Tailwind value'
  impact: 'local'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'ui-design'
    - 'spacing'
    - 'compact-layout'

- timestamp: 2026-01-21T18:31:00Z
  file: frontend/src/components/IssueCard.tsx
  context: 'Implementing compact single-line issue card layout'
  category: 'styling'
  question: 'Should flex alignment use items-center or items-start for wrapped text?'
  decision: 'Use items-start to align badges with first line of wrapped descriptions'
  reasoning: 'Long descriptions wrap to multiple lines. items-start keeps badges aligned with first line, creating clean visual hierarchy. items-center would center badges vertically with all lines, looking awkward.'
  alternatives:
    - 'Use items-center - would look unbalanced for wrapped text'
    - 'Use items-baseline - inconsistent with icon alignment'
  impact: 'local'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'flexbox'
    - 'alignment'
    - 'responsive-design'

- timestamp: 2026-01-21T18:32:00Z
  file: frontend/src/components/IssueCard.tsx
  context: 'Implementing human-readable evaluator names'
  category: 'patterns'
  question: 'What fallback order should be used for display name when multiple fields exist?'
  decision: 'Use fallback order: issue.category → title → evaluatorName'
  reasoning: 'Category is most semantic (e.g., "Content Quality & Focus"). Title is second choice (might be verbose). EvaluatorName is last resort (machine-readable like "01-content-quality"). Follows semantic priority from most to least human-readable.'
  alternatives:
    - 'Use title first (might be too verbose for badge)'
    - 'Use evaluatorName directly (not human-readable)'
    - 'Format evaluatorName by removing numbers and converting hyphens'
  impact: 'local'
  confidence: 'medium'
  source: 'ai-agent'
  tags:
    - 'display-logic'
    - 'fallback-strategy'
    - 'ux'

- timestamp: 2026-01-21T18:33:00Z
  file: frontend/src/App.tsx
  context: 'Expanding main content width for better screen space utilization'
  category: 'styling'
  question: 'What max-width should replace max-w-7xl (1280px)?'
  decision: 'Use max-w-[1600px] for main content area'
  reasoning: 'Increases usable width by 25% (1280px → 1600px). Fits comfortably on modern displays (1920px+) while leaving margins. Plan specified 1600px as target width.'
  alternatives:
    - 'Use max-w-screen-2xl (1536px) - standard Tailwind class but narrower'
    - 'Use max-w-full (100%) - too wide, loses readability'
    - 'Use 1400px - not wide enough for stated goals'
  impact: 'global'
  confidence: 'high'
  source: 'pattern-matching'
  tags:
    - 'layout'
    - 'responsive-design'
    - 'screen-width'

- timestamp: 2026-01-21T18:34:00Z
  file: frontend/src/App.tsx
  context: 'Adjusting grid proportions for wider layout'
  category: 'styling'
  question: 'What grid column ratio should replace 4-column (25%/75%) split?'
  decision: 'Use 5-column grid with filter=1 and issues=4 (20%/80% split)'
  reasoning: 'Gives more space to issues list (~1280px on 1600px displays). Filter panel only needs ~320px width. 20%/80% split maximizes issue content area while keeping filters accessible.'
  alternatives:
    - 'Use 6 columns (1/5 split = 16.67%/83.33%) - filter too narrow'
    - 'Keep 4 columns (25%/75%) - not taking advantage of wider layout'
    - 'Use 8 columns (1/7 = 12.5%/87.5%) - filter too cramped'
  impact: 'module'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'grid-layout'
    - 'proportions'
    - 'responsive-design'

- timestamp: 2026-01-21T19:00:00Z
  file: src/shared/evaluation/file-consistency-validator.ts
  context: 'Renaming file-consistency-validator to follow numbered evaluator naming convention'
  category: 'naming'
  question: 'What number prefix should the file-consistency-validator use to match other evaluators?'
  decision: 'Use "00-file-consistency" prefix to indicate it is a special pre-check validator'
  reasoning: 'Numbered evaluators range from 01-18. Using 00 conveys that this is a "zeroth" check that runs before the LLM-based evaluators. It maintains alphabetical ordering in listings while distinguishing it as a special built-in validator rather than an LLM prompt-based evaluator.'
  alternatives:
    - 'Use 19 to continue the sequence (but would imply it runs after other evaluators)'
    - 'Keep unnumbered (inconsistent with UI display of other evaluators)'
    - 'Use prefix like "pre-" instead of number'
  impact: 'global'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'naming-convention'
    - 'evaluator-design'
    - 'ui-consistency'

- timestamp: 2026-01-21T20:15:00Z
  file: src/shared/evaluation/cleanup-manager.ts
  context: 'Implementing automatic cleanup of temporary data after successful evaluation'
  category: 'architecture'
  question: 'Should tmp/clones cleanup happen relative to workingDir or project root?'
  decision: 'Clean up tmp/clones at project root (process.cwd()) instead of relative to workingDir'
  reasoning: 'git-cloner creates tmp/clones at project root, not relative to the cloned repo. For local path evaluations, workingDir might be anywhere on the filesystem. Consistent cleanup location matches creation location.'
  alternatives:
    - 'Clean up relative to workingDir'
    - 'Try both locations (project root and workingDir)'
    - 'Pass cleanup path as parameter from engine'
  impact: 'module'
  confidence: 'high'
  source: 'pattern-matching'
  tags:
    - 'cleanup'
    - 'file-system'
    - 'temporary-data'

- timestamp: 2026-01-21T20:16:00Z
  file: src/shared/evaluation/cleanup-manager.ts
  context: 'Implementing automatic cleanup of temporary data after successful evaluation'
  category: 'error-handling'
  question: 'Should cleanup errors fail the evaluation or be logged and ignored?'
  decision: 'Use best-effort cleanup - catch all errors, log them, and continue without throwing'
  reasoning: 'Cleanup is a housekeeping operation. Failing the entire evaluation due to cleanup errors (permissions, file locks, etc.) would be too strict. Better to complete evaluation successfully and log cleanup failures.'
  alternatives:
    - 'Throw exceptions on cleanup errors'
    - 'Silently ignore all errors without logging'
    - 'Return error status but continue evaluation'
  impact: 'module'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'error-handling'
    - 'robustness'
    - 'cleanup'

- timestamp: 2026-01-21T20:17:00Z
  file: src/shared/evaluation/engine.ts
  context: 'Integrating cleanup into evaluation engine'
  category: 'architecture'
  question: 'Should cleanup run in the try block or the finally block?'
  decision: 'Run cleanup in finally block after existing repo cleanup'
  reasoning: 'Finally block ensures cleanup runs regardless of success or failure path. However, we only actually clean files on success (using evaluationSucceeded flag). This pattern ensures cleanup is attempted even if the code takes unexpected paths.'
  alternatives:
    - 'Run in try block before return statement'
    - 'Run in catch block (only on error)'
    - 'Run as separate post-processing step'
  impact: 'module'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'control-flow'
    - 'cleanup'
    - 'error-handling'

- timestamp: 2026-01-21T20:18:00Z
  file: src/shared/evaluation/engine.ts
  context: 'Integrating cleanup into evaluation engine'
  category: 'patterns'
  question: 'How should we track evaluation success to conditionally run cleanup?'
  decision: 'Use evaluationSucceeded boolean flag set to true just before return, initialized to false in try block'
  reasoning: 'Simple boolean flag avoids complex state tracking. Set to true only when reaching the successful return statement. Default false ensures cleanup does not run if evaluation throws before completion.'
  alternatives:
    - 'Check for absence of error in catch block'
    - 'Track success in a result wrapper object'
    - 'Use separate success/failure callbacks'
  impact: 'local'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'state-management'
    - 'control-flow'
    - 'cleanup'

- timestamp: 2026-01-21T20:19:00Z
  file: src/shared/evaluation/cleanup-manager.ts
  context: 'Implementing cleanupEmptyParentDirs function'
  category: 'patterns'
  question: 'Should directory removal walk up the tree until hitting stopAt or stop at first non-empty directory?'
  decision: 'Stop at first non-empty directory OR stopAt boundary, whichever comes first'
  reasoning: 'Walking up to remove all empty parents until hitting a non-empty one is standard behavior for cleanup utilities. Respects stopAt boundary to avoid deleting project structure. Similar to rmdir -p behavior.'
  alternatives:
    - 'Only remove the exact directory specified, not parents'
    - 'Always walk up to stopAt even if directories are not empty'
    - 'Remove all parents up to stopAt regardless of contents'
  impact: 'module'
  confidence: 'high'
  source: 'pattern-matching'
  tags:
    - 'file-system'
    - 'cleanup'
    - 'directory-traversal'

- timestamp: 2026-01-21T20:20:00Z
  file: src/shared/evaluation/cleanup-manager.ts
  context: 'Implementing cleanup behavior on evaluation failure'
  category: 'patterns'
  question: 'Should debug output be preserved on evaluation failure?'
  decision: 'Always preserve debug output when evaluation fails, only cleanup on success'
  reasoning: 'Debug files (prompts and responses) are critical for troubleshooting failures. Automatic cleanup on failure would destroy valuable debugging information. Only safe to remove after confirmed successful evaluation.'
  alternatives:
    - 'Clean up regardless of success/failure'
    - 'Add separate flag for failure cleanup behavior'
    - 'Keep debug output for N hours then auto-delete'
  impact: 'global'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'debugging'
    - 'cleanup'
    - 'failure-handling'

- timestamp: 2026-01-21T21:00:00Z
  file: frontend/src/App.tsx
  context: 'Separating Issues tab into Errors and Suggestions tabs'
  category: 'architecture'
  question: 'Should filterOptionCounts use baseIssues or displayIssues as the source?'
  decision: 'Use baseIssues (tab-filtered) as the source for filterOptionCounts calculation'
  reasoning: 'Filter counts should reflect what is available to filter in the current tab. Using baseIssues ensures that when on the Errors tab, severity/category counts only show errors, not suggestions. This creates a more intuitive filtering experience.'
  alternatives:
    - 'Use displayIssues (would show counts across all issues regardless of tab)'
    - 'Use filteredIssues (would show counts after filters applied, creating circular logic)'
  impact: 'module'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'filtering'
    - 'ui-state'
    - 'tab-awareness'

- timestamp: 2026-01-21T21:01:00Z
  file: frontend/src/App.tsx
  context: 'Separating Issues tab into Errors and Suggestions tabs'
  category: 'patterns'
  question: 'How should tab badge counts behave when filters are active?'
  decision: 'Show filtered count when on that tab, show total count when on other tabs'
  reasoning: 'Active tab badge reflects current filtered view. Other tabs show total available so users know how many items are in those tabs before switching. Provides clear visual feedback about filter impact without hiding information.'
  alternatives:
    - 'Always show filtered count for all tabs'
    - 'Always show total count for all tabs'
    - 'Show filtered/total ratio (e.g., "5/12")'
  impact: 'module'
  confidence: 'medium'
  source: 'ai-agent'
  tags:
    - 'ui-design'
    - 'badges'
    - 'filtering'

- timestamp: 2026-01-21T21:02:00Z
  file: frontend/src/App.tsx
  context: 'Separating Issues tab into Errors and Suggestions tabs'
  category: 'patterns'
  question: 'What priority order should smart default tab selection use?'
  decision: 'Use priority: errors (if > 0) → suggestions (if > 0) → summary'
  reasoning: 'Errors are higher priority (must fix) so should default to errors tab when present. Suggestions are next (nice to have). Summary is fallback when no issues exist. Matches semantic importance of issue types.'
  alternatives:
    - 'Always default to summary tab'
    - 'Default to whichever type has more issues'
    - 'Default to suggestions first (less intimidating)'
  impact: 'module'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'default-behavior'
    - 'ux'
    - 'priority'

- timestamp: 2026-01-21T21:03:00Z
  file: frontend/src/App.tsx
  context: 'Separating Issues tab into Errors and Suggestions tabs'
  category: 'patterns'
  question: 'How should backward compatibility for old "issues" tab URLs be handled?'
  decision: 'Redirect "issues" tab to "errors" tab using handleTabChange within activeTab useMemo'
  reasoning: 'Errors are semantically closer to "issues" (problems to fix) than suggestions. Calling handleTabChange updates the URL to "errors" so subsequent renders use the correct tab. Maintains URL consistency.'
  alternatives:
    - 'Show an error message for invalid tab'
    - 'Redirect to summary tab instead'
    - 'Create a merged view showing both errors and suggestions'
  impact: 'global'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'backward-compatibility'
    - 'url-routing'
    - 'migration'

- timestamp: 2026-01-21T22:00:00Z
  file: src/api/index.ts
  context: 'Making evaluators count dynamic instead of hardcoded'
  category: 'architecture'
  question: 'Should evaluators list be hardcoded or dynamically read from filesystem?'
  decision: 'Dynamically read evaluator files from prompts/evaluators/ directory using readdir()'
  reasoning: 'Hardcoded EVALUATOR_FILES array must be updated manually every time a new evaluator is added. Dynamic reading eliminates maintenance burden and automatically reflects new evaluator files without code changes. Matches the embedded mode which also uses dynamic list.'
  alternatives:
    - 'Keep hardcoded array and update manually'
    - 'Generate the array as part of build step'
    - 'Use a configuration file'
  impact: 'global'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'maintenance'
    - 'file-system'
    - 'api-endpoints'

- timestamp: 2026-01-21T22:01:00Z
  file: src/api/index.ts
  context: 'Implementing dynamic evaluator file filtering'
  category: 'patterns'
  question: 'What criteria should filter evaluator files in the directory?'
  decision: 'Filter for files ending with .md and matching regex /^\d{2}-/ (two-digit prefix pattern)'
  reasoning: 'All evaluators follow numbered naming convention (01-content-quality.md, etc.). Regex ensures only properly numbered evaluators are included, filtering out non-evaluator markdown files if present. Explicit pattern matching prevents accidental inclusion.'
  alternatives:
    - 'Only check .md extension without number validation'
    - 'Use explicit include list of patterns'
    - 'Check for specific prefix like "evaluator-"'
  impact: 'global'
  confidence: 'high'
  source: 'pattern-matching'
  tags:
    - 'filtering'
    - 'naming-convention'
    - 'regex'

- timestamp: 2026-01-21T22:02:00Z
  file: src/api/index.ts
  context: 'Implementing dynamic evaluator list endpoint'
  category: 'patterns'
  question: 'Should dynamically loaded evaluators be sorted?'
  decision: 'Sort evaluators by ID using localeCompare() after loading'
  reasoning: 'readdir() does not guarantee order. Sorting ensures consistent ordering (01, 02, 03, ...) in UI dropdowns and API responses. localeCompare provides locale-aware string comparison that handles numbers correctly.'
  alternatives:
    - 'Use readdir() order without sorting'
    - 'Sort numerically by extracting number prefix'
    - 'Sort by file modification time'
  impact: 'global'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'sorting'
    - 'api-response'
    - 'consistency'

- timestamp: 2026-01-21T22:03:00Z
  file: src/api/index.ts
  context: 'Removing hardcoded EVALUATOR_FILES array'
  category: 'error-handling'
  question: 'How should single evaluator endpoint handle file not found errors?'
  decision: 'Catch file read errors, check for ENOENT error code, return 404 for missing files and 500 for other errors'
  reasoning: 'Distinguishes between "evaluator does not exist" (404) and "file system error" (500). Proper HTTP status codes improve API usability and debugging. Checking error.code === "ENOENT" is standard Node.js pattern for file-not-found detection.'
  alternatives:
    - 'Return 404 for all errors'
    - 'Return 500 for all errors'
    - 'Pre-validate evaluatorId against available list'
  impact: 'module'
  confidence: 'high'
  source: 'pattern-matching'
  tags:
    - 'error-handling'
    - 'http-status-codes'
    - 'api-design'

- timestamp: 2026-01-21T18:00:00Z
  file: src/shared/evaluation/evaluator-types.ts
  context: Adding evaluator type filtering functionality
  category: architecture
  decision: Use filter-first approach where type filter is applied before count limit
  reasoning: More intuitive behavior - users select a type (all/errors/suggestions) and get all evaluators of that type, rather than filtering a count-limited set. This ensures "Errors Only" always returns all 14 error evaluators, not just the first N errors from a pre-filtered list.
  alternatives:
    - Apply count limit first, then filter by type (would give inconsistent results)
    - Separate count and filter parameters with independent behavior
  impact: global
  confidence: high
  source: ai-agent
  tags:
    - filtering
    - user-experience
    - evaluator-selection

- timestamp: 2026-01-21T18:15:00Z
  file: frontend/src/components/GitHubUrlInput.tsx
  context: Replacing evaluator count selector with filter selector in frontend
  category: architecture
  decision: Replace count selector entirely with filter type selector instead of adding filter as additional control
  reasoning: Simplifies UI by reducing decision points. Plan specified replacing the selector, and having both count + filter would be confusing. Filter provides more semantic value than raw count (e.g., "Errors Only" is clearer than "14 evaluators").
  alternatives:
    - Keep both count selector and filter selector
    - Add filter as separate dropdown alongside count
    - Use tabs or radio buttons for filter selection
  impact: module
  confidence: high
  source: pattern-matching
  tags:
    - ui-design
    - simplification
    - frontend

- timestamp: 2026-01-21T18:30:00Z
  file: src/shared/evaluation/evaluator-types.ts
  context: Implementing getEvaluatorCountByType function
  category: patterns
  decision: Hardcode the evaluator file list in getEvaluatorCountByType instead of importing EVALUATOR_FILES from runner.ts
  reasoning: Avoids circular dependency (evaluator-types is imported by runner). The file list is stable and defined in both places. Alternative would be to extract EVALUATOR_FILES to a separate constants file, but that adds unnecessary complexity for a stable 19-item array.
  alternatives:
    - Create src/shared/evaluation/evaluator-constants.ts to export EVALUATOR_FILES
    - Use dynamic import to avoid circular dependency
    - Calculate count from EVALUATOR_CONFIGS and filter out non-LLM entries
  impact: local
  confidence: medium
  source: ai-agent
  tags:
    - circular-dependency
    - code-organization
    - constants

- timestamp: 2026-01-21T18:45:00Z
  file: src/shared/evaluation/evaluator-types.ts
  context: Creating filter helper functions
  category: patterns
  decision: Place filter functions in evaluator-types.ts alongside existing type classification functions
  reasoning: Evaluator type classification and filtering are closely related concerns. The filterEvaluatorsByType function uses EVALUATOR_CONFIGS which is already in this file. Keeps all evaluator type logic centralized.
  alternatives:
    - Create new src/shared/evaluation/evaluator-filter.ts file
    - Place functions in runner.ts near usage
    - Create evaluator-utils.ts for helper functions
  impact: module
  confidence: high
  source: pattern-matching
  tags:
    - code-organization
    - cohesion
    - file-structure

- timestamp: 2026-01-21T19:00:00Z
  file: frontend/src/components/GitHubUrlInput.tsx
  context: Determining evaluator count to pass to API
  category: architecture
  decision: Always pass totalEvaluators (19) to API and let backend apply filter, rather than calculating filtered count in frontend
  reasoning: Backend owns the filtering logic and count calculation. Frontend just selects the filter type. This keeps the source of truth on the backend and avoids duplicate logic. The backend will handle the math of filter + count correctly.
  alternatives:
    - Calculate filtered count in frontend using getEvaluatorCountByType
    - Pass different counts based on selected filter (14 for errors, 5 for suggestions)
  impact: module
  confidence: high
  source: ai-agent
  tags:
    - separation-of-concerns
    - backend-authority
    - frontend-backend

- timestamp: 2026-01-21T19:15:00Z
  file: src/shared/evaluation/evaluator-types.test.ts
  context: Writing unit tests for new filter functions
  category: testing
  decision: Import EVALUATOR_FILES from runner.ts in test file to verify filter behavior with actual evaluator list
  reasoning: Tests should verify behavior against real data. Using the actual EVALUATOR_FILES array ensures tests catch regressions if evaluators are added/removed. Test file doesn't have circular dependency concerns that production code has.
  alternatives:
    - Create mock evaluator array in test file
    - Hardcode expected counts (19, 14, 5) without verifying against real list
  impact: local
  confidence: high
  source: ai-agent
  tags:
    - testing
    - test-data
    - verification

- timestamp: 2026-01-21T19:30:00Z
  file: src/cli/index.ts
  context: Adding CLI validation for evaluator filter flag
  category: patterns
  decision: Validate --evaluator-filter immediately in the action handler before executing command
  reasoning: Follows existing pattern in the codebase - see validation for --report and --agent flags around lines 98-104. Fail fast with clear error message rather than passing invalid value through the system.
  alternatives:
    - Validate in evaluate-command.ts instead
    - Use Commander's built-in choices() validation
    - Skip validation and let TypeScript types handle it
  impact: local
  confidence: high
  source: pattern-matching
  tags:
    - validation
    - cli
    - error-handling

- timestamp: 2026-01-22T10:30:00Z
  file: src/shared/types/evaluation.ts
  context: 'Adding phantom file support for subdirectory AGENTS.md suggestions'
  category: 'architecture'
  question: 'Should phantom file indicator be a boolean field or use string prefix in snippetError?'
  decision: 'Use explicit isPhantomFile boolean field in BaseIssue interface'
  reasoning: 'More type-safe and self-documenting than parsing string prefixes. Follows existing pattern of using explicit fields for issue metadata (isMultiFile, evaluatorName, etc.)'
  alternatives:
    - 'Use snippetError prefix like "[PHANTOM_FILE] message"'
    - 'Add new issue type "phantom" alongside error/suggestion'
  impact: 'global'
  confidence: 'high'
  source: 'pattern-matching'
  tags:
    - 'types'
    - 'issue-schema'
    - 'phantom-files'

- timestamp: 2026-01-22T10:45:00Z
  file: src/shared/claude/response-parser.ts
  context: 'Implementing phantom file detection in snippet population'
  category: 'error-handling'
  question: 'Should phantom file check happen before or after fuzzy matching?'
  decision: 'Check for phantom files only after content lookup fails (line 390-399)'
  reasoning: 'If a file unexpectedly exists, we should show it even if marked as phantom. Only show phantom message when file truly does not exist.'
  alternatives:
    - 'Check isPhantomFile first and skip all content lookup'
    - 'Always show phantom message regardless of file existence'
  impact: 'module'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'error-handling'
    - 'snippet-extraction'
    - 'phantom-files'

- timestamp: 2026-01-22T10:50:00Z
  file: frontend/src/components/IssueCard.tsx
  context: 'Designing UI for phantom file display'
  category: 'styling'
  question: 'What color scheme should distinguish phantom files from regular errors?'
  decision: 'Use blue color scheme (border-blue-500/50, bg-blue-900/10, text-blue-400) for phantom files'
  reasoning: 'Blue represents informational/suggestion state without alarm. Contrasts with severity colors (red/orange/yellow) and neutral slate. Follows existing color system documented in CLAUDE.md'
  alternatives:
    - 'Use purple to indicate special state'
    - 'Use green to indicate opportunity'
    - 'Use different slate shade to stay neutral'
  impact: 'module'
  confidence: 'high'
  source: 'pattern-matching'
  tags:
    - 'ui'
    - 'color-system'
    - 'phantom-files'

- timestamp: 2026-01-22T10:55:00Z
  file: frontend/src/components/IssueCard.tsx
  context: 'Choosing icon for phantom file display'
  category: 'styling'
  decision: 'Use document-plus icon for phantom files instead of info icon'
  reasoning: 'Visually communicates "file to be created" concept. Info icon suggests general error, while document-plus suggests action/creation opportunity'
  alternatives:
    - 'Use folder-plus icon'
    - 'Keep info icon with different color'
    - 'Use custom SVG for phantom file'
  impact: 'local'
  confidence: 'medium'
  source: 'ai-agent'
  tags:
    - 'ui'
    - 'icons'
    - 'phantom-files'

- timestamp: 2026-01-22T11:00:00Z
  file: prompts/evaluators/11-subdirectory-coverage.md
  context: 'Defining phantom file format in evaluator prompt'
  category: 'patterns'
  question: 'What line numbers should phantom files use in their location?'
  decision: 'Use start: 1, end: 1 as placeholder line numbers for phantom files'
  reasoning: 'Line 1 is semantically meaningful (start of file) while being obviously placeholder since real issues span multiple lines. Avoids special sentinel values like 0 or -1'
  alternatives:
    - 'Use start: 0, end: 0 as sentinel'
    - 'Use start: -1, end: -1 to indicate special case'
    - 'Omit line numbers entirely for phantom files'
  impact: 'global'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'evaluator-prompts'
    - 'phantom-files'
    - 'conventions'

- timestamp: 2026-01-22T11:10:00Z
  file: src/shared/claude/response-parser.test.ts
  context: 'Writing tests for phantom file handling'
  category: 'testing'
  decision: 'Test both isPhantomFile=true and isPhantomFile=false cases explicitly'
  reasoning: 'Ensures the boolean logic is tested, not just presence/absence of field. Catches edge case where false is treated differently than undefined'
  alternatives:
    - 'Only test true vs undefined'
    - 'Only test happy path with isPhantomFile=true'
  impact: 'module'
  confidence: 'high'
  source: 'pattern-matching'
  tags:
    - 'testing'
    - 'phantom-files'
    - 'edge-cases'

- timestamp: 2026-01-22T13:40:00Z
  file: frontend/src/hooks/useFeedbackApi.ts
  context: 'Stopping assessment page fetch loop by stabilizing hook functions'
  category: 'patterns'
  question: 'How should API hook functions be stabilized to avoid re-render loops?'
  decision: 'Wrap all API methods in useCallback and memoize the returned object with useMemo'
  reasoning: 'Stable function identities prevent useEffect dependencies from retriggering on each render, while useMemo avoids recreating the returned object every render.'
  alternatives:
    - 'Only wrap getAggregateFeedback in useCallback'
    - 'Use useEffect with empty dependency array and disable lint rule'
    - 'Move API methods outside the hook to module scope'
  impact: 'module'
  confidence: 'medium'
  source: 'ai-agent'
  tags:
    - 'react-hooks'
    - 'memoization'
    - 'api'

- timestamp: 2026-01-23T19:00:00Z
  file: src/shared/providers/opencode-provider.ts
  context: 'Adding debugging to diagnose OpenCode parsing issue'
  category: 'patterns'
  question: 'What length should stdout and stderr previews be in debug output?'
  decision: 'Use 200 characters for stdout preview and 500 characters for stderr content'
  reasoning: 'stdout preview is typically structured JSON so 200 chars is enough to see format. stderr often contains error messages/logs that need more context, so 500 chars gives better diagnostic value. Both sizes fit comfortably in terminal output without overwhelming.'
  alternatives:
    - 'Use same length (200 or 500) for both'
    - 'Use 100 chars (too short for debugging)'
    - 'Use 1000 chars (too verbose for quick scan)'
  impact: 'local'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'debugging'
    - 'logging'
    - 'opencode-provider'

- timestamp: 2026-01-23T19:01:00Z
  file: src/shared/providers/opencode-provider.ts
  context: 'Adding debugging to diagnose OpenCode parsing issue'
  category: 'patterns'
  question: 'How should newlines be displayed in debug output previews?'
  decision: 'Replace newlines with "\\n" escape sequence using .replace(/\n/g, "\\n")'
  reasoning: 'Makes multi-line output readable on a single line in logs. Escaping shows structure without breaking log formatting. Standard practice in debugging tools.'
  alternatives:
    - 'Keep actual newlines (would break log formatting)'
    - 'Replace with spaces (loses structure information)'
    - 'Truncate at first newline (loses multi-line context)'
  impact: 'local'
  confidence: 'high'
  source: 'pattern-matching'
  tags:
    - 'debugging'
    - 'string-formatting'
    - 'logging'

- timestamp: 2026-01-23T19:02:00Z
  file: src/shared/providers/opencode-provider.ts
  context: 'Adding debugging to diagnose OpenCode parsing issue'
  category: 'patterns'
  question: 'Where should the diagnostic message about stderr/stdout mismatch be placed?'
  decision: 'Place diagnostic immediately after exitCode check, before parseJsonResponse call'
  reasoning: 'Diagnostic runs only when exit code is 0 (success) but output is unexpected. Positioning it right before parsing helps correlate the diagnostic with subsequent parsing behavior. Still inside verbose block to respect quiet mode.'
  alternatives:
    - 'Place after parseJsonResponse (would be after parsing fails)'
    - 'Place in parseJsonResponse itself (couples parsing with I/O logging)'
    - 'Add as separate logging section later'
  impact: 'local'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'code-organization'
    - 'debugging'
    - 'logging-placement'

- timestamp: 2026-01-23T19:15:00Z
  file: src/shared/providers/opencode-provider.ts
  context: 'Fixing OpenCode model specification to include provider prefix'
  category: 'patterns'
  question: 'What format should the model parameter use for OpenCode CLI?'
  decision: 'Use provider-prefixed format "openai/gpt-5.2-codex" instead of just "gpt-5.2-codex"'
  reasoning: 'OpenCode CLI requires models in provider/model format. The error showed OpenCode was parsing "gpt-5" as the provider ID from "gpt-5.2-codex", which does not exist. The correct format includes the OpenAI provider prefix.'
  alternatives:
    - 'Keep "gpt-5.2-codex" and configure OpenCode default provider'
    - 'Make model configurable via environment variable'
    - 'Try other model naming patterns'
  impact: 'global'
  confidence: 'high'
  source: 'pattern-matching'
  tags:
    - 'opencode-provider'
    - 'model-configuration'
    - 'bug-fix'
- timestamp: 2026-01-23T20:30:00Z
  file: src/shared/evaluation/engine.ts
  context: 'Fixing curation threshold configuration and UI display'
  category: 'patterns'
  question: 'What should the default curation threshold be for error and suggestion curation?'
  decision: 'Set default curation threshold to 30 issues for both errorTopN and suggestionTopN'
  reasoning: 'User explicitly requested "curate by default 30 issues" after observing that the previous default of 20 was too restrictive. Logs showed 63 errors were curated to 20, resulting in too few displayed issues in the UI. Increasing to 30 provides better coverage while still maintaining curation benefits.'
  alternatives:
    - 'Keep 20 as default (original value, but user found it too restrictive)'
    - 'Use 40 or 50 for more coverage (but loses curation benefit of focusing on top issues)'
    - 'Make thresholds different for errors vs suggestions'
  impact: 'global'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'curation'
    - 'configuration'
    - 'user-preference'
- timestamp: 2026-01-23T20:30:00Z
  file: src/shared/claude/response-parser.ts
  context: 'Implementing root-level file preference for basename-only references'
  category: 'patterns'
  question: 'When multiple files have same basename (e.g., AGENTS.md), which should be preferred for basename-only references?'
  decision: 'Prefer root-level file (path without "/" separator) when multiple files match basename'
  reasoning: 'Root-level AGENTS.md is conventionally the "main" documentation. User suggested this convention during discussion. Resolves ambiguity without forcing evaluators to always use full paths. Fallback to error only if no root-level file exists.'
  alternatives:
    - 'Always error when multiple files match (too strict)'
    - 'Use first match found (arbitrary and inconsistent)'
    - 'Prefer deepest nested file (counterintuitive)'
  impact: 'global'
  confidence: 'high'
  source: 'pattern-matching'
  tags:
    - 'file-resolution'
    - 'basename-matching'
    - 'conventions'

- timestamp: 2026-01-23T20:31:00Z
  file: src/shared/claude/response-parser.ts
  context: 'Implementing root-level file preference for basename-only references'
  category: 'patterns'
  question: 'How should root-level file be detected from relative path?'
  decision: 'Use !path.includes("/") to detect root-level files'
  reasoning: 'Simple and reliable. Root-level files have no directory separator. Works for both forward slashes (Unix/Mac) and is sufficient since git always uses forward slashes for relative paths.'
  alternatives:
    - 'Check path === basename (redundant)'
    - 'Count "/" characters and require 0 (equivalent but more complex)'
    - 'Use path.dirname() and check for "." (more overhead)'
  impact: 'local'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'string-parsing'
    - 'file-paths'
    - 'simplicity'

- timestamp: 2026-01-23T20:32:00Z
  file: src/shared/evaluation/runner.ts
  context: 'Updating warning message for multiple files with same basename'
  category: 'patterns'
  question: 'How should the warning message change given the new root-level preference?'
  decision: 'Change from warning (⚠️) to info (ℹ️) when root-level file exists, show warning only when no root-level file'
  reasoning: 'Having multiple files with same name is not a problem anymore when root-level exists (it is the default). Only a concern when NO root-level file exists and evaluators must use full paths. Info vs warning distinction helps users understand severity.'
  alternatives:
    - 'Always show warning (creates alarm fatigue)'
    - 'Never show any message (loses transparency)'
    - 'Only show on error (too late)'
  impact: 'module'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'logging'
    - 'user-feedback'
    - 'warning-severity'

- timestamp: 2026-01-23T20:33:00Z
  file: src/shared/claude/response-parser.test.ts
  context: 'Adding tests for root-level file preference'
  category: 'testing'
  question: 'What test cases should verify the root-level preference logic?'
  decision: 'Test two cases: (1) root + subdirs → prefers root content, (2) only subdirs → errors with ambiguity message'
  reasoning: 'Covers both success path (root exists) and failure path (no root). Verifies content matching and error message format. Minimal test set that proves the logic works correctly.'
  alternatives:
    - 'Only test success case (incomplete)'
    - 'Test all permutations of file locations (overkill)'
    - 'Test with 3+ files (redundant)'
  impact: 'module'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'testing'
    - 'test-coverage'
    - 'minimal-test-set'

- timestamp: 2026-01-26T19:30:00Z
  file: src/shared/evaluation/evaluator-types.ts
  context: 'Fixing test failures in context-scorer caused by evaluator name lookup'
  category: 'patterns'
  question: 'How should evaluator names be normalized before looking up their configuration?'
  decision: 'Strip numbering prefix using regex /^\d+-/ before looking up evaluator in EVALUATOR_CONFIGS'
  reasoning: 'Tests use numbered evaluator names (e.g., "11-subdirectory-coverage.md") but EVALUATOR_CONFIGS uses unprefixed names (e.g., "subdirectory-coverage.md"). Regex pattern matches one or more digits followed by hyphen, covering all current evaluators (01-19). Simple and consistent with actual file naming convention.'
  alternatives:
    - 'Use regex /^\d{2}-/ to require exactly 2 digits (would break if evaluator count exceeds 99)'
    - 'Split on first hyphen and take second part (more complex, same result)'
    - 'Maintain two separate mappings for prefixed and unprefixed names (duplication)'
  impact: 'module'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'bug-fix'
    - 'evaluator-types'
    - 'regex'
    - 'naming-convention'

- timestamp: 2026-01-27T15:15:46Z
  file: frontend/src/styles.css
  context: 'Reducing agent status icon size in provider detection cards'
  category: 'styling'
  question: 'What icon size should be used for agent status checkmarks - user requested "reduce the height" without specifying exact size?'
  decision: 'Use w-12 h-12 (48px) for agent status icons and remove absolute positioning'
  reasoning: 'Original icons were too large (screenshot showed oversized checkmarks). 48px is a reasonable icon size for card-based UI - large enough to be visible but not overwhelming. Removed absolute positioning (top-2 right-2) since icons should be centered in the card flow, not floating in corner. Added mb-3 for spacing below icons.'
  alternatives:
    - 'Use w-8 h-8 (32px) - might be too small for prominent status indicator'
    - 'Use w-16 h-16 (64px) - still too large, not addressing user concern'
    - 'Use w-10 h-10 (40px) - slightly smaller but similar'
  impact: 'local'
  confidence: 'medium'
  source: 'ai-agent'
  tags:
    - 'ui-design'
    - 'icon-sizing'
    - 'frontend'
    - 'provider-detection'

- timestamp: 2026-01-27T15:17:41Z
  file: frontend/src/styles.css
  context: 'Second iteration: further reducing agent status icon size based on user feedback'
  category: 'styling'
  question: 'User said 48px was still too large - how much smaller should the icons be?'
  decision: 'Reduce from w-12 h-12 (48px) to w-6 h-6 (24px) for agent status icons'
  reasoning: '24px is a standard size for inline status indicators and icon badges. Represents a 50% reduction from the previous attempt. This size is commonly used for checkmarks, status icons, and small UI indicators in modern web applications.'
  alternatives:
    - 'Use w-8 h-8 (32px) - still might feel too large'
    - 'Use w-5 h-5 (20px) - might be too small to see clearly'
    - 'Use w-4 h-4 (16px) - likely too small for this context'
  impact: 'local'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'ui-design'
    - 'icon-sizing'
    - 'iterative-design'
    - 'user-feedback'

- timestamp: 2026-01-28T21:20:00Z
  file: src/api/db/database.ts
  context: 'Fixing SQLite database path for binary portability'
  category: 'architecture'
  question: 'What directory should the SQLite database use - relative to bundle, current working directory, user home, or project root?'
  decision: 'Use process.cwd() to create database relative to current working directory'
  reasoning: 'In bundled binaries, import.meta.dir points to virtual bundle filesystem (/$bunfs/root/) which resolved to system /data/ requiring root permissions. process.cwd() ensures database is created where user executes the binary, making it portable and avoiding permission issues. Users expect data to be in their working directory. Similar to how git, docker, and other CLI tools create local state.'
  alternatives:
    - 'Use user home directory (~/.agents-md-evaluator/data) - less visible, harder to find database'
    - 'Use OS temp directory - would lose data between runs'
    - 'Use import.meta.dir (original approach) - fails in bundled binaries'
  impact: 'global'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'database'
    - 'portability'
    - 'binary-bundling'
    - 'file-system'

- timestamp: 2026-01-30T13:15:00Z
  file: frontend/index.html
  context: 'Fixing unstyled frontend after CSS was not being imported'
  category: 'architecture'
  question: 'Should CSS be imported via JavaScript import or linked in HTML?'
  decision: 'Link CSS via <link rel="stylesheet" href="./dist/output.css"> in HTML instead of importing in App.tsx'
  reasoning: 'Based on previous assumption correction (2026-01-25), Bun bundler creates incomplete chunk CSS files when CSS is imported in JavaScript, missing Tailwind @apply styles from @layer components. Linking directly in HTML ensures the full compiled output.css is used in both dev and production.'
  alternatives:
    - 'Import CSS in App.tsx with import "../dist/output.css" (causes @apply styles to be dropped by Bun bundler)'
    - 'Use separate build step to inject CSS link during production build only (complexity overhead)'
  impact: 'global'
  confidence: 'high'
  source: 'pattern-matching'
  tags:
    - 'css'
    - 'tailwind'
    - 'bun-bundler'
    - 'frontend-build'
    - 'production-compatibility'
